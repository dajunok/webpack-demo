
@import "./other.less";
.container{
  h1{
       font-size: 25px;
       color:#E45456;
 }
  p{
       font-size: 25px;
       color:#3C7949;
  }

 .myclass{
  h1{
        font-size: 25px;
        color:#E45456;
  }
  p{
       font-size: 25px;
       color:@color1+@color2;
  }
 }
}

/* 变量 */
@color1:#3C7949;
@color2:#64321E;

/* Mixins语言特性 */
.a{
  color: red;
}

.b{
  .a();
}

/* 函数 */
@color3: #FF8000;
@width:1.0;
.mycolor{
color: @color3;
 width: percentage(@width);
}

/* 命名空间及访问器 */

.class1 {
  .class2 {
    .liu(@param) {
      font-size: @param;
      color:green;
    }
  }
}
.myclass {
  .class1 > .class2 > .liu(20px);
}
//--------------------------------
.jun(@font-size,@color){
  font-size: @font-size;
  color:@color;
}
.myname{
  .jun(18px,red);
}


/* Less 变量范围 */
@var: @a;
@a: 15px;
.myclass {
  font-size: @var;
  @a:20px;
  color: green;
}

/* Less 选择器变量 */
@nav:p div;
@{nav} {
  background: #2ECCFA;
}
//----------------
@mySelector: #wrap;
@Wrap: wrap;
@{mySelector}{ //变量名 必须使用大括号包裹
  color: #999;
  width: 50%;
}
.@{Wrap}{
  color:#ccc;
}
#@{Wrap}{
  color:#666;
}
/* Less 属性变量 */
@borderStyle: border-style;
@Soild:solid;
#wrap{
  @{borderStyle}: @Soild;//变量名 必须使用大括号包裹
}
//---------------------------------
@my-property: color;
.myclass {
  background-@{my-property}: #81F7D8;
}
/*Less url变量*/
@images: "../img";//需要加引号
body {
  background: url("@{images}/dog.png");//变量名 必须使用大括号包裹
}

/*Less 声明变量
  有点类似于 下面的 混合方法
  结构: @name: { 属性: 值 ;};
  使用：@name();
*/
@background: {background:red;};
#main{
    @background();
}
@Rules:{
    width: 200px;
    height: 200px;
    border: solid 1px red;
};
#con{
  @Rules();
}
//Less 变量作用域
@var: @a;
@a: 100%;
#wrap {
  width: @var;
  @a: 9%;
}

//用变量去定义变量
@fnord:  "I am fnord.";
@var:    "fnord";
#wrap::after{
  content: @@var; //将@var替换为其值 content:@fnord;
}

/*嵌套
  1、& 的妙用      & ：代表的上一层选择器的名字，此例便是header。
*/
#header{
  &:after{
    content:"Less is more!";
  }
  .title{
    font-weight:bold;
  }
  &_content{//理解方式：直接把 & 替换成 #header
    margin:20px;
  }
}

/*Less Import语句
  import语句可以具有保存路径的变量。当你引用一个普通的父目录时，这是非常有用的。
*/
@path : "//webpack-demo.com:8080/web/css";
@import "@{path}/index.css";
.myclass{
 color : #A52A2A;
}
/*Less 变量延迟加载
在延迟加载中，即使它们尚未声明，也可以使用变量。
*/
p {
  font-size: @a;
  color: #ca428b;
}
@a: @b;
@b: 25px;

/*Less 扩展
  Extend是一个LESS伪类，它通过使用:extend 选择器在一个选择器中扩展其他选择器样式。
*/
h2 {
  &:extend(.style);
  font-style: italic;
}
.style {
  background: green;
}

/*Less 混合
混合类似于编程语言中的函数。 Mixins是一组CSS属性，允许您将一个类的属性用于另一个类，并且包含类名作为其属性。 
在LESS中，可以使用类或id选择器以与CSS样式相同的方式声明mixin。
它可以存储多个值，并且可以在必要时在代码中重复使用。
*/

/*1、LESS 不输出Mixin， 可以创建一个mixin，它可以通过简单地放置括号后在输出中消失。*/
.a(){
  padding-left: 100px;
}
.myclass{
  background : #64d9c0;
  .a;
}
/*2、LESS Mixins中的选择器。mixins不仅可以包含属性，还可以包含选择器。*/
.mixin() {
  &:hover {
    background: #FFC0CB;
  }
}
a {
  .mixin();
}
/*3、LESS Mixin命名空间。命名空间用于在通用名称下对mixin进行分组。 
  使用命名空间可以避免名称冲突，并从外部封装mixin组。
*/
#outer() {
  background:yellow;
  .inner {
    color: red;
  }
}
p {
  #outer > .inner;
}

/*4、LESS 保护的命名空间。当guard应用于命名空间时，只有在guard条件返回true时才使用由命名空间定义的mixin。 
命名空间防护类似于mixins上的guard。
*/
@color : blue;
#namespace when (@color = blue) {
  .mixin() {
   color: red;
  }
}
p{
 #namespace .mixin();
}
/*5、LESS !important 关键字
！important 关键字用于覆盖特定属性。 当它在mixin调用之后放置时，它会将所有继承的属性标记为！important 。
*/
.mixin5(){
  color: #900;
  background: #F7BE81;
}
.para1{
  .mixin5();
}
.para2{
  .mixin5() !important;
}

//============================================================================================

/*Less 混合参数
参数mixin使用一个或多个参数，通过参数和其属性来扩展LESS的功能，以便在混合到另一个块时自定义mixin输出。
*/

//==========================================================================================
.border(@width; @style; @color) {
    border: @width @style @color;
}
.myheader {
    .border(2px; dashed; green);
}
/*1、LESS Mixins具有多个参数。
  参数可以使用逗号或分号分隔。 使用逗号符号，可以将其解释为mixin参数分隔符或css列表分隔符。 如果在mixin中使用分号，那么它将用分号分隔参数，CSS列表将包含所有逗号。
  它包括一些关于分号和逗号的点，如下所示：
  如果你有两个参数，那么它们将包含逗号分隔的列表。 例如 .class1(1，2，3; sometext，other thing)。
  如果有三个参数，并且只包含数字，例如 .class1(1，2，3)。
  您可以使用带有逗号分隔列表的虚拟分号，例如 .class1(1，2，3;)。
  有逗号分隔的默认值。 例如 .class1(@color：gray，green;)
*/
.mixin(@color) {
  color: @color;
}
.mixin(@color; @padding: 2) {
  color: @color;
  padding: @padding;
}

.myclass {
  .mixin(#FE9A2E);
}

/*2、LESS 命名参数
Mixins通过使用它们的名称提供参数值而不是位置。 参数没有放置值的任何顺序，它们可以通过名称引用。 
命名参数的结果更容易阅读，并提供清晰的代码。
*/
.mixin6(@color: black; @fontSize: 10px) {
  color: @color;
  font-size: @fontSize;
}
.class1 {
  .mixin6(@fontSize: 20px; @color: #F5A9D0);
}
.class2 {
  .mixin6(#F79F81; @fontSize: 20px);
}

/*3、LESS @arguments 变量
当调用mixin时， @arguments 包括所有传递的参数。 当不想使用单个参数时， @arguments 变量很有用。
*/
.box-shadow(@x: 0; @y: 0; @height: 3px; @width: 3px) {
  -webkit-box-shadow: @arguments;
     -moz-box-shadow: @arguments;
          box-shadow: @arguments;
}
.myclass {
  .box-shadow(2px; 2px);
}

/*4、LESS 高级参数和@rest Variable
Mixin通过使用 ... 提供可变数量的参数。 您可以通过在变量名称后面放置 ... 为变量赋值参数。
让我们看看一些使用参数的简单格式如下所示：
.mixin(...) {        // it matches arguments from 0-n
.mixin() {           // it matches exactly 0 arguments
.mixin(@x: 1) {      // it matches arguments from 0-1
.mixin(@x: 1; ...) { // it matches arguments from 0-n
.mixin(@x; ...) {
*/
.mixin7(@listofvariables...) {
  border: @listofvariables;
}
p {
  .mixin7(1px; solid; red);
}
//-----------------------------
.mixin8(@color,@rest...) {   //@rest绑定除@color参数的所有参数
  color: @color; 
  padding: @rest;
}
div {
.mixin8(red; 10px; 20px; 5px; 5px);
}

/*5、LESS 模式匹配。您可以通过向其传递参数来更改mixin的行为。*/
.mixin9(dark; @color) {
  color: darken(@color, 15%);
}
.mixin9(light; @color) {
  color: lighten(@color, 15%);
}

@color-new: dark;

.myclass {
  .mixin9(@color-new; #FF0000);
}






